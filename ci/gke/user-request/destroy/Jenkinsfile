pipeline {
    // @see https://www.jenkins.io/doc/book/pipeline/syntax/#agent-parameters
    agent any

    environment {
        DOWNSTREAM_JOB = "destroy-gke-cluster"
        READWRITE_BUCKET_CREDENTIALS_ID = "sa-gcloud"
        TERRAFORM_MODULES_GIT_REPO_URL = 'https://github.com/pacphi/docker-terraform-and-jenkins.git'
        TERRAFORM_MODULES_GIT_REPO_BRANCH = 'main'
        OPERATOR_MANIFEST_GIT_REPO_URL = 'https://github.com/pacphi/docker-terraform-and-jenkins.git'
        OPERATOR_MANIFEST_GIT_REPO_BRANCH = 'operator'
        OPERATOR_MANIFEST_FILENAME = 'cr.v1.yaml'
    }

    parameters {
        string(name: 'USER_REQUEST_BUILD_TAG', description: 'Originating create-user-request pipeline job id')
        string(name: 'USER_MANIFEST_GIT_REPO_URL', description: 'A Git repository URL')
        string(name: 'USER_MANIFEST_GIT_REPO_BRANCH', description: 'A Git repository branch')
        string(name: 'USER_MANIFEST_FOLDER', defaultValue: '', description: 'The relative path from the root of the repository from which to source the manifest file')
        choice(name: 'USER_MANIFEST_FILENAME', choices: ['cr.v1.yaml'], description: 'The filename and version of the manifest')
        choice(name: 'TARGET_ENVIRONMENT', choices: ['test', 'staging'], description: 'Select a target environment')
    }

    stages {

        stage("clone terraform modules repo") {
            steps {
                cleanWs()
                git branch: "${env.TERRAFORM_MODULES_GIT_REPO_BRANCH}", url: "${env.TERRAFORM_MODULES_GIT_REPO_URL}"
            }
        }

        stage("fetch configuration and trigger downstream job") {
            agent {
                // @see https://stackoverflow.com/questions/44206339/jenkins-declarative-pipeline-docker-registry if you would like to adapt the params below to source container image from private registry
                docker {
                    image 'gcr.io/google.com/cloudsdktool/cloud-sdk:latest'
                    args  '--rm -e HOME=/tmp'
                    reuseNode true
                }
            }
            steps {
                // @see https://www.jenkins.io/doc/pipeline/steps/pipeline-utility-steps/ < this plugin must be installed
                script {
                    sh('mkdir .operator')

                    dir('.operator') {
                         git branch: "${env.OPERATOR_MANIFEST_GIT_REPO_BRANCH}", url: "${env.OPERATOR_MANIFEST_GIT_REPO_URL}"
                    }
                    
                    def operator_manifest_folder = "${env.WORKSPACE}/.operator/${env.TARGET_ENVIRONMENT}"
                    def operator_manifest = readYaml file: "${operator_manifest_folder}/${env.OPERATOR_MANIFEST_FILENAME}"

                    // trigger downstream job
                    build job: "${env.DOWNSTREAM_JOB}", parameters: [
                        string(name: 'USER_REQUEST_BUILD_TAG', value: "${env.USER_REQUEST_BUILD_TAG}"),
                        string(name: 'READWRITE_BUCKET_CREDENTIALS_ID', value: "${env.READWRITE_BUCKET_CREDENTIALS_ID}"),
                        string(name: 'CREDENTIALS_BUCKET', value: "gs://${operator_manifest.cluster.service_account.bucket.name}"),
                        string(name: 'SECRETS_BUCKET', value: "gs://${operator_manifest.terraform.buckets.secrets.name}"),
                        string(name: 'VARS_BUCKET', value: "gs://${operator_manifest.terraform.buckets.vars.name}")
                    ]
                }
            }
        } 
    }

    post {
        // Always runs. And it runs before any of the other post conditions.
        always {
            // Wipe out the workspace before we finish!
            deleteDir()
        }
    }
        
    // The options directive is for configuration that applies to the whole job.
    options {
        // Make sure we only keep 10 builds at a time, so we don't fill up our storage!
        buildDiscarder(logRotator(numToKeepStr:'10'))
            
        // And we'd really like to be sure that this build doesn't hang forever, so
        // let's time it out after 10 minutes.
        timeout(time: 10, unit: 'MINUTES')
    }
}